---
title: "sp.scRNAseq Vignette"
author: "Jason T. Serviss and Martin Enge"
date: '`r Sys.Date()`'
output:
    html_document:
        theme: flatly
        toc: yes
vignette: >
    %\VignetteIndexEntry{ClusterSignificance Vignette} 
    %\VignetteEngine{knitr::rmarkdown} 
    %\usepackage[utf8]{inputenc}
    %\SweaveUTF8
---

<style>
    .col2 {
        columns: 2 200px;         /* number of columns and width in pixels*/
        -webkit-columns: 2 200px; /* chrome, safari */
        -moz-columns: 2 200px;    /* firefox */
    }
</style>

```{r style, echo = FALSE, results = 'asis', eval = TRUE}
BiocStyle::markdown()
packages <- c("sp.scRNAseq", "printr")
purrr::walk(packages, library, character.only = TRUE)
rm(packages)
```

## Introduction

sp.scRNAseq works in 3 stages with each stage being supported by plotting functions. The stages are as follows:

1. Creating the sp.scRNAseq counts object for singlets and multiplets. 
   * Here counts and ercc counts are input and stored. As well, counts per million (cpm) and log2 cpm are calculated.
2. Dimensionality reduction and classification with singlets. 
   * Dimensionality reduction is performed with the single cells using tSNE. Resulting clusters are classified, forming a blueprint of the possible cell types present in the tissue. Performed in 4 steps:
      - Feature selection
      - Distance calculation
      - t-SNE
      - Classification
3. Multuplet deconvolution via swarm optimization. 
   * Here we utilize swarm optimization to deconvolute the multuplets and, thus, provide an overview of the tissue "connectome".
        
## spCounts method

Make sp.scRNAseq counts object. The spCounts command takes 2 arguments:

1. matrix; The raw counts data with gene IDs as rownames and sample IDs as colnames. 
2. matrix; The ERCC spike-in counts data with gene IDs as rownames and sample IDs as colnames. 

We use the testCounts and testErcc datasets, included in the package, to initialize the sp.scRNAseq counts object. The testCounts variable contains singlets that comprise 10 cell types. Each cell type has 85 singlets and each singlet has 250 gene expression values. The dataset also includes 2 multuplets comprised of 4 different cell types each. The multuplets are comprised in such a way that, in the final results, there should be one connection between cell types A1, B1, C1, and D1 as well as one connection between G1, H1, I1, and J1.

```{r}
testCounts[1:2, 1:2] #example
dim(testCounts) #genes and sample numbers
table(colnames(testCounts)) # sample names
head(rownames(testCounts)) #example of gene names
class(testCounts) #must be a matrix
```

We first divide the counts data into singlets and multiplets and make an spCounts object for each. In the test data, the colnames of all singlet samples are prefixed with an "s" and all multiplets are prefixed with an "m".

```{r, eval = TRUE}
s <- grepl("^s", colnames(testCounts))
cObjSng <- spCounts(testCounts[,s], testErcc[,s])
cObjMul <- spCounts(testCounts[,!s], testErcc[,!s])

#show counts objects
cObjSng
cObjMul
```

The counts object contains:
1. The raw counts data input by the user.
2. The log normalized counts per million.
3. The counts per million.
4. The counts.ercc input by the user (if these are not available they can be substituted using matrix())

### Accessors

Individual slots within the counts object can be accessed with the "getData" function. Note that all other sp.scRNAseq objects slots can be accessed in the same way. See below:

```{r, eval = TRUE}
counts <- getData(cObjSng, "counts")
```

### ERCC fraction plot

The fractions of ERCC spike-ins and the number of approximated cells can be viewed in a plot using the spPlot command and specifying the type of plot desired.
```{r, fig.align='center', fig.height=8, fig.width=10, eval=TRUE, message=FALSE}
plotCounts(cObjSng, cObjMul, type = "ercc")
```

### Markers plot

Sometimes it may be desireable to view the expression of marker genes in the counts object. At the moment, this can only be accomplished with 2 markers at a time.

```{r, fig.align='center', fig.height=8, fig.width=10, eval=TRUE, message=FALSE}
plotCounts(cObjSng, cObjMul, type = "markers", markers = c("c1", "b1"))
```

## spUnsupervised method

The dimensionality reduction and classification stage can be regulated by passing multiple arguments to the spUnsupervised object constructor. The default values and descriptions are shown below:

1. spCounts: The sp.scRNAseq counts object.
2. theta = 0: Passed to Rtsne; Speed/accuracy trade-off (increase for less accuracy), set to 0.0 for exact TSNE.
3. k = 2: Passed to Rtsne; Output dimensionality. (This should actually not be changed).
4. max_iter = 20000: Passed to Rtsne; Number of iterations.
5. perplexity = 10: Passed to Rtsne; Perplexity parameter.
6. initial_dims = 50: Passed to Rtsne; The number of dimensions that should be retained in the initial PCA step.
7. Gmax = 50: Passed to mclust as 1:Gmax; An integer vector specifying the numbers of mixture components (clusters) for which the BIC is to be calculated.
8. seed = 11: Passed to set.seed.
9. type = "max": Used for filtering genes to be included in the analysis. Current options are "max", "var", and "manual". (max and var are currently working, "none" should be added)
10. max = 2000: The number of genes to keep when type = max or var. 
11. genes=NULL: The genes to include when type = manual.
12. weighted = TRUE: A logical indicating if the classified group means should be weighted with the uncertainty reported from mclust.

```{r, eval = TRUE}
uObj <- spUnsupervised(cObjSng, max_iter = 1000, max = 250, weighted = TRUE)
```

###Substitution

Individual slots can also be substituted in the spUnsupervised object. For example, to substitute the data contained in the classification slot we would use:

```{r, eval = TRUE}
classification(uObj) <- getData(uObj, "classification")
```

### Clusters plot

The results of the unsupervised clustering can be viewed using spPlot function and specifying the type as "clusters". The colors in the plot represent the classification of each cell. In addition, by default, the uncertainty from the cluster classification is represented with the size of the point. Even though this dataset is very "well behaved", we can see that points residing on the edges of some of the clusters have a higher degree of associated uncertainty than points residing in the middle of the clusters.

```{r, fig.align='center', fig.height=8, fig.width=10, eval=TRUE, message=FALSE}
plotUnsupervised(uObj, type = "clusters")
```

### Markers plot

The sp.scRNAseq unsupervised object also has an associated markers plot where the markers can be visualized overlayed with the unsupervised clustering results.

```{r, fig.align='center', fig.height=8, fig.width=10, eval=TRUE, message=FALSE}
plotUnsupervised(uObj, cObjSng, type = "markers", markers = c("c1", "b1"))
```

## spSwarm method

Finally, the deconvolution of the multuplets take place in this stage. Again, the associated arguments are listed and explained below:

1. spUnsupervised: The sp.scRNAseq unsupervised object.
2. limit = "none": This can be used to randomly pick a limited number of multuplets to be analyzed and can be useful for fine-tuning the paramaters.
3. maxiter = 10: Passed to pySwarm; The maximum number of iterations for the swarm to search.
4. swarmsize = 150: Passed to pySwarm; The number of particles in the swarm.
5. minstep = 1e-16: Passed to pySwarm; The minimum stepsize of swarm’s best position before the search terminates.
6. minfunc = 1e-16: Passed to pySwarm; The minimum change of swarm’s best objective value before the search terminates.
7. cutoff = 0.2: This is used to specify a fraction under which the contribution of a specific cellType is viewed as background. (should be approximatley 1/max(cells in a multuplet))
8. cores=1: This step is able to run in parallel by specifying the number of desired cores here.

```{r, eval = TRUE}
cellNrs <- estimateCells(cObjSng, cObjMul)
sObj <- spSwarm(
  cObjMul, 
  uObj,
  distFun = "dtsnCellNum",
  swarmsize = 150,
  cores = 2,
  maxiter = 10,
  cellNumbers = cellNrs,
  e = 0.0025
)
```

### spSwarm results

We can exmaine the resulting connections with the `spSwarmPoisson` command:

```{r, eval = TRUE}
spSwarmPoisson(sObj, edge.cutoff = 1/10.5, min.num.edges = 0, min.pval = 1)
```

This reports all of the detected edges. The edge.cutoff argument specifies the fraction above which and edge is considered to be valid. Since the optimization vector is essentially a fraction, for an edge to be considered we can set the edge.cutoff to 1/(number of cell types + error margin). We can specify the number of edges a connection must have to be reported with the *min.num.edges* argument and also filter results for a specific significance level with the *min.pval* argument.

### spSwarm plot

The resulting "connectome" can be plotted via the commands below. Here we need to provide the plot function with the 

```{r, fig.align='center', fig.height=8, fig.width=10, eval=TRUE, message=FALSE}
plotSwarm(sObj, uObj, cObjSng, edge.cutoff = 1/10.5, min.num.edges = 1, type = "tsne")
```

In addition "self connections" can be turned on via specifying the "loop" argument as TRUE.
Several other plot layouts are included like the "heat" layout shown below:

```{r, fig.align='center', fig.height=8, fig.width=10, eval=TRUE, message=FALSE, warning=FALSE}
plotSwarm(sObj, uObj, cObjSng, type = "heat", edge.cutoff = 1/10.5, min.num.edges = 1)
```

### Residual plot
Residuals (define residuals) for multiplets and edges can also be plotted using the spSwarm object as shown below:

Multiplets:
```{r, fig.align='center', fig.height=8, fig.width=10, eval=TRUE, message=FALSE, warning=FALSE}
plotSwarm(sObj, uObj, cObjSng, cObjMul, type = "multiplets", edge.cutoff = 1/10.5, min.num.edges = 1)
```

Edges:
```{r, fig.align='center', fig.height=8, fig.width=10, eval=TRUE, message=FALSE, warning=FALSE}
plotSwarm(sObj, uObj, cObjSng, cObjMul, type = "edges", edge.cutoff = 1/10.5, min.num.edges = 1)
```

## Helper functions

Write about the various helper functions to pluck information from the objects, mostly the spSwarm objects.
