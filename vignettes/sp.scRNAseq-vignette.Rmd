---
title: "sp.scRNAseq Vignette"
author: "Jason T. Serviss and Martin F. Enge"
date: '`r Sys.Date()`'
output:
    html_document:
        theme: flatly
        toc: yes
        code_folding: show
vignette: >
    %\VignetteIndexEntry{ClusterSignificance Vignette} 
    %\VignetteEngine{knitr::rmarkdown} 
    %\usepackage[utf8]{inputenc}
    %\SweaveUTF8
---

<style>
    .col2 {
        columns: 2 200px;         /* number of columns and width in pixels*/
        -webkit-columns: 2 200px; /* chrome, safari */
        -moz-columns: 2 200px;    /* firefox */
    }
</style>

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
knitr::opts_chunk$set(fig.align='center', fig.width=8, fig.height=6)
library(sp.scRNAseq)
library(printr)
library(knitr)

##the function below allows dynamic insertion of the function source code of S3 and S4 methods
insert_funS3 = function(name) {
  read_chunk(lines = capture.output(dump(name, '')), labels = paste(name, 'source', sep = '-'))
}
insert_funS4 = function(name, signature) {
  read_chunk(lines = format(getMethod(name, signature)@.Data), labels = paste(name, signature, 'source', sep = '-'))
}
```

##Introduction
Interaction maps from incompletely dissociated primary tissue
Advances in singlecell
biology has enabled us to investigate isolated single cells at an
unprecedented resolution. Current methods can measure subtle changes in cell state, revealing
specialized minor subpopulations within a cell type. However, functional characterization of such
subpopulations is still challenging. A promising approach to untangling functional
characterization is spatial transcriptomics, where genomewide
measurements of gene
expression are enriched with spatial attributes. Such approaches allow us to determine the
relative positions of cell subpopulations. Unfortunately, current spatial transcriptomic
approaches suffer either from problems with sensitivity, are limited to a restricted panel of
genes, or the spatial attributes are of low resolution.
In order to deconvolute the cell connectome, we sort multiplets of incompletely dissociated cells
along with single cells from the same sample. The single cells provide a set of blueprints of
possible subcell
types, and subsequently we machine learning approaches to infer the
composition of multiplets. Using this method we can measure the composition of a very large
number of multiplets onto a lattice consisting of subcell
types of arbitrary complexity.

## Package funcions and pre-analysis processing

```{r, echo=FALSE}
pathToFiles <- system.file('previousData/Doublet_project_data.rda', package='sp.scRNAseq')
load(pathToFiles)
rm(counts.log, groups.mat, optim.res.all.2, pathToFiles)
```

To begin we must have read count data from both singlet and multuplet samples in a 
matrix with genes as rows (gene name indicated by rowname) and samples as columns (sample name
indicated by colname). As well, we need the ERCC spike-in counts in the same format
as the counts.

```{r}
counts[1:3, 1:3]
```

```{r}
counts.ercc[1:3, 1:3]
```

To begin we want to initialize an object of class spCounts. We accomplish
this with the [spCounts][Functions] function in the following manner:

```{r}
expData <- spCounts(
    counts=counts,
    counts.ercc=counts.ercc,
    sampleType = '1000102901'
)
```

The *sampleType* argument specifies an identifier in the sample names that indicates 
that the sample is a multuplet (and not a singlet). 

This results in a object of class spCounts with 4 slots. We can view the slots and a
summary of their contens with the command [show][Functions]. 
The screen output shows that *expData* contains 4 slots; *counts*, *counts.log*, 
*counts.ercc*, and *sampleType*. When the object is initialized the counts.log slot 
is filled using the internal [.norm.log.counts][Functions] function. In addition, 
the sampleType slot is filled with the [.sampleType][Functions] function and 
contains a character vector indicating if each individual sample is a singlet 
or multuplet.

```{r}
show(expData)
```

Each slot can be accessed using the [getData][Functions] function 
shown below:

```{r}
c <- getData(expData, "counts")
c[1:3, 1:3]
```

We next want to filter the samples based on their quality, disregarding samples which
may be of poor quality and hinder the downstream analysis. We can accomplish this with 
the [filterCells][Functions] function demonstrated below.

```{r}
expData <- filterCells(expData)
```

Various types of plots can be generated during the analysis process using the 
[spPlot][Functions] function and specifying the *type* argument 
dependant on which plot is desired.

<br></br><br></br>

## ERCC counts 

The ERCC counts can be viewed in each sample type by using the 
[spPlot][Functions] function and specifying type as *ercc*.

```{r erccPlot}
spPlot(expData, type="ercc")
```

## Cellular identity markers {.tabset}

We can also plot cellular markers using the [spPlot][Functions] function using type as *markers*. 
We also need to use the *markers* argument to identify which 2 markers we are interested
in plotting. Select the tabs below to see the markers plotted for this dataset.

### INS and GCG
```{r marker1}
spPlot(expData, type="markers", markers=c('INS', 'GCG'))
```

No INS/GCG doublets

### INS and THY1
```{r marker2}
spPlot(expData, type="markers", markers=c('INS', 'THY1'))
```

Only doublets, should be bona fide... These might be an interesting subpopulation to check out

### GCG and THY1
```{r marker3}
spPlot(expData, type="markers", markers=c('GCG', 'THY1'))
```

Also interesting

### INS and NEUROG3
```{r marker4}
spPlot(expData, type="markers", markers=c('INS', 'NEUROG3'))
```

Frequently coexpressed in single cells

### NEUROG3 and THY1
```{r marker5}
spPlot(expData, type="markers", markers=c('NEUROG3', 'THY1'))
```

One doublet neurogenin+ / mesenchymal cells.

### FLT1 and THY1
```{r marker6}
spPlot(expData, type="markers", markers=c('FLT1', 'THY1'))
```

Endothelial / Mesenchymal doublets

### EPCAM and THY1
```{r marker7}
spPlot(expData, type="markers", markers=c('EPCAM', 'THY1'))
```

Epithelial / Mesenchymal doublets

### PROM1 and THY1
```{r marker8}
spPlot(expData, type="markers", markers=c('PROM1', 'THY1'))
```

Ductal / Mesenchymal doublets

### PROM1 and FLT1
```{r marker9}
spPlot(expData, type="markers", markers=c('PROM1', 'FLT1'))
```

Ductal / Endothelial doublets





<br></br><br></br>

## Single cell unsupervised ML

We now want to use an unsupervised clustering method to deduce the types of cells present 
in the single cells. To do this we first utilize the TSNE method to cluster the single cells 
afterwhich, we utilize the MCLUST package to identify discrete culsters in the results. This 
can be performed and the results plotted using the commands below:

```{r, echo=FALSE}
data(unsupervised)
```

```{r unsupervised, echo=TRUE, message=FALSE, eval=FALSE}
unsupervised <- spUnsupervised(expData)
```

```{r clustersPlot}
spPlot(unsupervised, type="clusters")
```

The results indicate that 7 discrete clusters are identified in the singlets. 

## Multuplet identification

To be continued....


## Functions {.tabset}

```{r functions, echo=FALSE}
#spCounts
insert_funS4("spCounts", "matrix")
norm.log.counts <- sp.scRNAseq:::.norm.log.counts
insert_funS3("norm.log.counts")
sampleType <- sp.scRNAseq:::.sampleType
insert_funS3("sampleType")

#show for signature spCounts
insert_funS4("show", "spCounts")
showCounts <- sp.scRNAseq:::.showCounts
insert_funS3("showCounts")
showMatrix <- sp.scRNAseq:::.showMatrix
insert_funS3("showMatrix")
showBasics <- sp.scRNAseq:::.showBasics
insert_funS3("showBasics")

#show for signature spUnsupervised
insert_funS4("show", "spUnsupervised")
showUnsupervised <- sp.scRNAseq:::.showUnsupervised
insert_funS3("showUnsupervised")
showList <- sp.scRNAseq:::.showList
insert_funS3("showList")

#getData for signature spCounts
insert_funS4("getData", "spCounts")

#getData for signature spCounts
insert_funS4("getData", "spUnsupervised")

#filterCells
insert_funS4("filterCells", "spCounts")

#spPlot for signature spCounts
insert_funS4("spPlot", "spCounts")
erccPlot <- sp.scRNAseq:::.erccPlot
insert_funS3("erccPlot")
markersPlot <- sp.scRNAseq:::.markersPlot
insert_funS3("markersPlot")

#spPlot for signature spUnsupervised
insert_funS4("spPlot", "spUnsupervised")
spClustersPlot <- sp.scRNAseq:::.spClustersPlot
insert_funS3("spClustersPlot")
spMarkersPlot <- sp.scRNAseq:::.spClustersPlot
insert_funS3("spMarkersPlot")

#spUnsupervised
insert_funS4("spUnsupervised", "spCounts")
ntopF <- sp.scRNAseq:::.ntopF
insert_funS3("ntopF")

```

###spCounts

```{r spCounts-source, results='hide'}
```

**.norm.log.counts**
```{r norm.log.counts-source, results='hide'}
```

**.sampleType**
```{r sampleType-source, results='hide'}
```

<br></br>

###show

####Signature spCounts
```{r show-spCounts-source, results='hide'}
```

**.showCounts**
```{r showCounts-source, results='hide'}
```

**.showMatrix**
```{r showMatrix-source, results='hide'}
```

**.showBasics**
```{r showBasics-source, results='hide'}
```

####Signature spUnsupervised
```{r show-spUnsupervised-source, results='hide'}
```

**.showUnsupervised**
```{r showUnsupervised-source, results='hide'}
```

**.showList**
```{r showList-source, results='hide'}
```

<br></br>

###getData

####Signature spCounts
```{r getData-spCounts-source, results='hide'}
```

####Signature spUnsupervised
```{r getData-spUnsupervised-source, results='hide'}
```

<br></br>

###filterCells
```{r filterCells-spCounts-source, results='hide'}
```

<br></br>

###spPlot

####Signature spCounts
```{r spPlot-spCounts-source, results='hide'}
```

**.erccPlot**
```{r erccPlot-source, results='hide'}
```

**.markersPlot**
```{r markersPlot-source, results='hide'}
```

####Signature spUnsupervised

```{r spPlot-spUnsupervised-source, results='hide'}
```

**.spClustersPlot**
```{r spClustersPlot-source, results='hide'}
```

**.spMarkersPlot**
```{r spMarkersPlot-source, results='hide'}
```

<br></br>

###spUnsupervised
```{r spUnsupervised-spCounts-source, results='hide'}
```

**.ntopF**
```{r ntopF-source, results='hide'}
```

<br></br>