packages <- c("sp.scRNAseq", "sp.scRNAseqData", "tidyverse", "future", "future.apply")
purrr::walk(packages, library, character.only = TRUE)
rm(packages)

##spCounts
s <- grepl("^s", colnames(countsSorted2))
cObjSng <- spCounts(countsSorted2[, s], countsSortedERCC2[, s])

m <- c('m.NJB00204.A02', 'm.NJB00204.G04', 'm.NJB00204.D07')
cObjMul <- spCounts(
  countsSorted2[, colnames(countsSorted2) %in% m], 
  countsSortedERCC2[, colnames(countsSortedERCC2) %in% m]
)

##spUnsupervised
uObj <- spUnsupervised(cObjSng)

#rename classes
midx <- match(rownames(getData(uObj, "tsne")), countsSortedMeta2$sample)
classification(uObj) <- countsSortedMeta2$cellTypes[midx]
groupMeans(uObj) <- averageGroupExpression(
  cObjSng, getData(uObj, "classification"), FALSE
)
tsneMeans(uObj) <- tsneGroupMeans(
  getData(uObj, "tsne"), getData(uObj, "classification")
)

##spSwarm
future::plan(multiprocess)

sObj <- spSwarm(cObjSng, cObjMul, uObj, maxiter = 10, swarmsize = 150, nSyntheticMultiplets = 400)
############################

n <- 400
#are the correct singlets subsetted?
idx <- purrr::map(1:n, ~sampleSinglets(classes))
expect_true(all(map_lgl(idx, function(i) identical(unname(classes[i + 1]), c("A375", "HCT116", "HOS")))))

sm <- idx %>%
  purrr::map(., ~subsetSinglets(singlets, .x)) %>%
  purrr::map(., function(x) {rownames(x) <- rownames(singlets); x}) %>%
  purrr::map(., function(x) {colnames(x) <- sort(unique(classes)); x}) %>%
  do.call("rbind", .)

cn <- map(idx, function(i) colnames(singlets)[i + 1])

nSelect <- length(selectInd)
a <- singlets[1:nSelect, cn[[1]]]
b <- sm[1:nSelect, ]
colnames(a) <- NULL
colnames(b) <- NULL

expect_identical(a, b)

start <- 1
end <- nSelect
lgl <- c()
for(i in 1:n) {
  names <- cn[[i]]
  synth <- unname(sm[start:end, ])
  real <- unname(singlets[, names])
  start <- start + nSelect
  end <- end + nSelect
  lgl[i] <- identical(synth, real)
}
expect_true(all(lgl))

#are the subsetted singlets of the correct class
classes <- getData(uObj, "classification")
names(classes) <- rownames(getData(uObj, "tsne"))
expect_true(all(map_lgl(cn, function(c) {
  identical(unname(classes[match(c, names(classes))]), c("A375", "HCT116", "HOS"))
})))

#####Try to set up a super simple ex and calculate "by hand" and compare results
classes <- rep(letters[1:2], each = 2)
singlets <- matrix(c(rep(1:10, 2), rep(11:20, 2)), ncol = 4)
rownames(singlets) <- LETTERS[1:nrow(singlets)]
n <- 2

sm <- purrr::map(1:n, ~sampleSinglets(classes)) %>%
  purrr::map(., ~subsetSinglets(singlets, .x)) %>%
  purrr::map2(., 1:n, function(x, i) {rownames(x) <- paste(rownames(singlets), i, sep = "."); x}) %>%
  purrr::map(., function(x) {colnames(x) <- sort(unique(classes)); x}) %>%
  do.call("rbind", .) %>%
  .[order(rownames(.)), ]

fractions <- rep(0.5, 2)
multiplets <- matrix(rep(rowSums(singlets[,2:3]), 2), ncol = 2)
oneMultiplet <- multiplets[, 1]

cost.cpp <- calculateCost(oneMultiplet, sm, fractions, n)

adj <- t(t(sm) * fractions)
rs <- rowSums(adj)
sm.hand <- matrix(rs, ncol = 2, byrow = TRUE)
dp <- dpois(round(oneMultiplet), sm.hand)
rm <- rowMeans(dp)
lrm <- log10(rm)
lrm[is.infinite(lrm)] <- -323.0052
cost <- sum(lrm) * (-1)
expect_equal(cost.cpp, cost)

#################
sngCPM <- getData(cObjSng, "counts.cpm")
mulCPM <- getData(cObjMul, "counts.cpm")
classes <- getData(uObj, "classification")
selectInd <- getData(uObj, "selectInd")
multiplets <- matrix(
  mulCPM[selectInd, ],
  ncol = ncol(mulCPM),
  dimnames = list(rownames(mulCPM)[selectInd], colnames(mulCPM))
)
singlets <- matrix(
  sngCPM[selectInd, ],
  ncol = ncol(sngCPM),
  dimnames = list(rownames(sngCPM)[selectInd], colnames(sngCPM))
)
singletSubset <- .subsetSinglets(classes, singlets, 400)
i <- 2
oneMultiplet <- round(multiplets[, i])
fractions <- as.numeric(getData(sObj, "spSwarm")[m[2], ])
calculateCostR(oneMultiplet, singletSubset, fractions, 400)
fractions2 <- c(0.5, 0, 0.5)


#######################
classes <- getData(uObj, "classification")
selectInd <- getData(uObj, "selectInd")
singlets <- matrix(
  sngCPM[selectInd, ],
  ncol = ncol(sngCPM),
  dimnames = list(rownames(sngCPM)[selectInd], colnames(sngCPM))
)
n <- 400

idx <- purrr::map(1:n, ~sampleSinglets(classes))

fun_wrong <- function(classes, singlets, n, idx) {
  tmp <- idx %>%
    purrr::map(., ~subsetSinglets(singlets, .x)) %>%
    purrr::map(., function(x) {rownames(x) <- rownames(singlets); x}) %>%
    #purrr::map2(., 1:n, function(x, i) {rownames(x) <- paste(rownames(singlets), i, sep = "."); x}) %>%
    purrr::map(., function(x) {colnames(x) <- sort(unique(classes)); x}) %>%
    do.call("rbind", .) %>%
    .[order(rownames(.)), ]
}

fun_right <- function(classes, singlets, n, idx) {
  tmp <- idx %>%
    purrr::map(., ~subsetSinglets(singlets, .x)) %>%
    purrr::map(., function(x) {rownames(x) <- 1:nrow(x); x}) %>%
    do.call("rbind", .) %>%
    .[order(as.numeric(rownames(.))), ]
}

fun_corrected <- function(classes, singlets, n, idx) {
  sub <- purrr::map(1:n, ~sampleSinglets(classes)) %>%
    purrr::map(., ~subsetSinglets(singlets, .x)) %>%
    purrr::map(., function(x) {rownames(x) <- 1:nrow(x); x}) %>%
    do.call("rbind", .) %>%
    .[order(as.numeric(rownames(.))), ]
  
  rownames(sub) <- paste(rep(rownames(singlets), each = n), 1:n, sep = ".")
  colnames(sub) <- sort(unique(classes))
  sub
}

wrong <- fun_wrong(classes, singlets, n, idx)
right <- fun_right(classes, singlets, n, idx)
corrected <- fun_corrected(classes, singlets, n, idx)


