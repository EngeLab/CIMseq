---
title: "Progress 1"
author: "Jason T. Serviss"
date: '`r Sys.Date()`'
output:
    html_document:
        theme: flatly
        toc: yes
---

<style>
    .col2 {
        columns: 2 200px;         /* number of columns and width in pixels*/
        -webkit-columns: 2 200px; /* chrome, safari */
        -moz-columns: 2 200px;    /* firefox */
    }
</style>

```{r style, echo = FALSE, results = 'hide'}
BiocStyle::markdown()
library(knitr)
library(printr)
library(optimx)

##the function below allows dynamic insertion of the function source code of S3 and S4 methods
insert_funS3 = function(name) {
  read_chunk(lines = capture.output(dump(name, '')), labels = paste(name, 'source', sep = '-'))
}
insert_funS4 = function(name, signature) {
  read_chunk(lines = format(getMethod(name, signature)@.Data), labels = paste(name, 'source', sep = '-'))
}
```


To evaluate the success/failure of specific methods which attempt to deduce cell types in the multuplets, I wanted to create a dataset of multuplets using the single cells. To do this I first used tsne to investigate the "types" of single cells. I did this using the [spUnsupervised][] function (which is basically uses the code you wrote but in a S4 method). The results were then saved to a dataset and are plotted below.   

```{r, fig.align='center', fig.width=8, fig.height=6}
library(sp.scRNAseq)
data(unsupervised)
spPlot(unsupervised, type="clusters")
```

```{r importAssembleTestData, echo=FALSE}
pathToFiles <- system.file('testData.R', package='sp.scRNAseq')
source(pathToFiles)
```

I used 3 of the groups from the usupervised clustering to combine single cells into multuplets. Groups four, seven, and eight were used since they seemed relativley unique from each other and included a relativley large number of single cells. The final dataset was compiled with the [assembleTestData][] function and includes 3 sets of doublets and 1 set of triplets:

```{r}
data(testData)
table(gsub(
    "([a-zA-Z]*)[0-9]*", 
    "\\1", 
    dimnames(testData)[2][[1]]
))
```

I then wanted to try different constrained optimization methods to see how well they perform on the dataset. I started using the optimx package as you had previously done to try to get a feeling for what is happening and what I expect as a result. To begin with I selected a subset of the total dataset to examine the outcome.

```{r defineOptimixFunctions, echo=FALSE}
make.synthetic.slice <- function(cell.types, fractions) {
    fractions <- fractions/sum(fractions)
    res <- apply(cell.types, 1, function(x) {sum(x*fractions)})
}

dist.to.slice <- function(fractions, cell.types, slice) {
    a <- make.synthetic.slice(cell.types, fractions)
    if(any(is.na(a))) {
        cat("NA in make synthetic slice!\n")
        cat(paste(fractions, sep="\t"), "\n")
    }
    cost <- sum(abs(a - slice))
    cost
}

.averageGroupExpression <- function(classes, sng) {
    classes <- unique(classes)
    means <- lapply(classes, function(x) {
        ingroup <- classes == x
        log2(rowMeans(2^sng[,ingroup]))
    })
    means <- as.matrix(as.data.frame(means))
    colnames(means) <- classes
    return(means)
}
```

```{r optimix1, eval=TRUE}
##get relevant data and subset singlets
classification <- getData(unsupervised, "mclust")$classification
counts.log <- getData(expData, "counts.log")
sampleType <- getData(expData, "sampleType")
sng <- counts.log[ ,sampleType == "Singlet"]

##calculate the average groups xpression and subset groups to be examined
clusterMeans <- .averageGroupExpression(classification, sng)
clusterMeans <- clusterMeans[ ,c('4', '7', '8')]
fractions <- rep(1.0/(dim(clusterMeans)[2]), (dim(clusterMeans)[2]))

##subset highly expressed genes to use
maxs <- order(apply(counts.log, 1, max), decreasing=T)
clusterMeans.top2000 <- 2^clusterMeans[maxs[1:1000],]
dbl.top2000 <- 2^testData[maxs[1:1000],]

##subset a number of the testData examples to use
set.seed(3)
type <- gsub("([a-zA-Z]*)[0-9]*", "\\1", names(testData))
l <- list(
    testData[ ,type==unique(type)[1]],
    testData[ ,type==unique(type)[1]],
    testData[ ,type==unique(type)[1]],
    testData[ ,type==unique(type)[1]]
)
names(l) <- unique(type)
set.seed(3)
l <- lapply(l, function(x) x[,sample(1:ncol(x), replace=FALSE, size=5)])

optim.res.all.2 <- lapply(1:(dim(dbl.top2000)[2]), function(i) {
    optimx(par=fractions, fn=dist.to.slice, gr=NULL, cell.types=clusterMeans.top2000, slice=dbl.top2000[,i], method=c("L-BFGS-B"), lower=0, upper=1)
})

groups.mat <- as.matrix(data.frame(lapply(optim.res.all.2, function(x) {unlist(x[1:3])})))
colnames(groups.mat) <- colnames(dbl.top2000)
rownames(groups.mat) <- c(4,7,8)

out <- as.data.frame(groups.mat, row.names = 1:nrow(groups.mat))
out$groups <- rownames(groups.mat)
out <- out[order(out$groups), ]
m <- reshape2::melt(out, id.vars="groups")
plyr::ddply(m, c("groups", "variable"), summarize, sum=sum(value))
```

So first maybe it is best for me to try to describe what I think is happening here...

My understanding of constrined optimization is the following; basically, we are representing something as a mathmatical function and we are trying to, in this case, find the minimum of that function. The function paramaters, in our case, are the fractions of each single cell type that make up the multuplet. The function is equal to the difference between the sum of the observed gene expression values in the different cell types and the gene expression values if the multuplet were an equal combination of all possible cell types. Or more simply stated, the "cost". So, via constrained optimization, we are trying to find the fractions of singlets that explains the multuplet with the minimum cost. The "constrained" part comes from the fact that, since we know some things about the paramaters, we can "constrain" them by saying to the optimization function that the paramaters must "follow these rules".

So for the test dataset there are 3 possible cell types that the multuplet can be comprised of, cell type 4, 7, or 8. So the paramaters we start with are 0.33, 0.33, and 0.33, i.e. each cell type contributes an equal amount to the multuplet. We only use the top 2000 genes with the highest expression and 


## Functions {.tabset}

```{r functionDefinitions, echo=FALSE}
insert_funS4("spUnsupervised", "spCounts")
insert_funS4("spPlot", "spUnsupervised")
insert_funS3("assembleTestData")
insert_funS3("dist.to.slice")
insert_funS3("make.synthetic.slice")
insert_funS3(".averageGroupExpression")


```

### spUnsupervised
```{r spUnsupervised-source, results='hide'}
```
<br></br>

### spPlot
```{r spPlot-source, results='hide'}
```
<br></br>

### assembleTestData
```{r assembleTestData-source, results='hide'}
```
<br></br>

### dist.to.slice
```{r dist.to.slice-source, results='hide'}
```
<br></br>

### make.synthetic.slice
```{r make.synthetic.slice-source, results='hide'}
```
<br></br>

### .averageGroupExpression
```{r .averageGroupExpression-source, results='hide'}
```
<br></br>

