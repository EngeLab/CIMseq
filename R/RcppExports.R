# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' sampleSinglets
#' 
#' This function takes a character vector of classes/cell with the same order
#' as the cells in the counts matrix. It returns one random index per unique
#' class and returns them as a integer vector.
#'
#' @param classes Character; a character vector of classes with length equal to
#' the number of cells for which counts exist.
#' @author Jason T. Serviss
#' @export
sampleSinglets <- function(classes) {
    .Call('_sp_scRNAseq_sampleSinglets', PACKAGE = 'sp.scRNAseq', classes)
}

#' subsetSingletsEigen
#' 
#' This function takes a counts matrix and subsets the columns according to the
#' indices provided by the idxToSubset argument.
#'
#' @param singlets Matrix; a counts matrix with cells/samples as columns and 
#' genes as rows.
#' @param idxToSubset Integer; the indexes of cells/samples to be subset. 
#' Typically generared using the \link{\code{subsetSinglets}} function.
#' @author Jason T. Serviss
#' @export
subsetSingletsEigen <- function(singlets, idxToSubset) {
    .Call('_sp_scRNAseq_subsetSingletsEigen', PACKAGE = 'sp.scRNAseq', singlets, idxToSubset)
}

#' adjustAccordingToFractionsEigen
#' 
#' This function takes a counts matrix and subsets the columns according to the
#' indices provided by the idxToSubset argument.
#'
#' @param fractions Numeric; a numeric vector with length equal to 
#' ncol(singlets) indicating the fractions that each column should be 
#' multiplied with.
#' @param singlets Matrix; a counts matrix with cells/samples as columns and 
#' genes as rows. This matrix should have been previously subset with the 
#' \link{\code{sampleSinglets}} and \code{subsetSingletsEigen} functions so that 
#' only one singlet per class/cell type is present.
#' @author Jason T. Serviss
#' @export
adjustAccordingToFractionsEigen <- function(fractions, singlets) {
    .Call('_sp_scRNAseq_adjustAccordingToFractionsEigen', PACKAGE = 'sp.scRNAseq', fractions, singlets)
}

#' multipletSumsEigen
#' 
#' This function takes a counts matrix and calculates the row sums.
#'
#' @param adjusted matrix; A counts matrix with cells/samples as columns and 
#' genes as rows. This matrix should have been previously subset with the 
#' \link{\code{sampleSinglets}} and \code{subsetSingletsEigen} functions so that
#' only one singlet per class/cell type is present. Furthermore, it should have
#' already been asjusted by the fractions using the 
#' \link{\code{adjustAccordingToFractionsEigen}} function.
#' @author Jason T. Serviss
#' @export
multipletSumsEigen <- function(singlets) {
    .Call('_sp_scRNAseq_multipletSumsEigen', PACKAGE = 'sp.scRNAseq', singlets)
}

#' poissonSample
#' 
#' This function takes the rowSums calculated by the 
#' \link{\code{multipletSumsArma}}.or \link{\code{multipletSumsEigen}} 
#' functions and randomly samples 1 value for each input using the Poisson 
#' distribution and the input value as lambda.
#'
#' @param rsRcpp Integer; vector of rounded row sums.
#' @author Jason T. Serviss
#' @export
poissonSample <- function(rsRcpp) {
    .Call('_sp_scRNAseq_poissonSample', PACKAGE = 'sp.scRNAseq', rsRcpp)
}

#' cpmC
#' 
#' Takes a numeric matrix of counts and calculates counts per million.
#'
#' @param counts Matrix; a counts matrix. Must be formated as numeric.
#' @author Jason T. Serviss
#' @export
cpmC <- function(counts) {
    .Call('_sp_scRNAseq_cpmC', PACKAGE = 'sp.scRNAseq', counts)
}

#' generateSyntheticMultipletsEigen
#' 
#' Wrapper for deconvolution cost function using the Eigen C++ library.
#'
#' @param singlets Matrix; a counts matrix with cells/samples as columns and 
#' genes as rows.
#' @param classes Character; a character vector of classes with length equal to
#' the number of cells for which counts exist.
#' @param fractions Numeric; a numeric vector with length equal to 
#' ncol(singlets) indicating the fractions that each column should be 
#' multiplied with.
#' @param n Integer; length 1 integer indicating the number of synthetic 
#' multiplets to generate.
#' @author Jason T. Serviss
#' @export
generateSyntheticMultipletsEigen <- function(singlets, classes, fractions, n) {
    .Call('_sp_scRNAseq_generateSyntheticMultipletsEigen', PACKAGE = 'sp.scRNAseq', singlets, classes, fractions, n)
}

#' calculateCostDensity
#' 
#' This function takes a vector of gene counts per million for one multiplet 
#' that is being deconvoluted and a matrix of synthetic multiplets. It then 
#' calculates the poisson density for each gene count and each corresponding 
#' value in the matrix row.
#'
#' @param oneMultiplet Numeric; a numeric vector of counts per million for one
#' multiplet.
#' @param syntheticMultiplets Matrix; a numeric matrix of synthetic multiplets
#' with samples as columns and genes as rows.
#' @author Jason T. Serviss
calculateCostDensity <- function(oneMultiplet, syntheticMultiplets) {
    .Call('_sp_scRNAseq_calculateCostDensity', PACKAGE = 'sp.scRNAseq', oneMultiplet, syntheticMultiplets)
}

#' calculateLogRowMeans
#' 
#' This function takes a matrix of poisson densities and calculates the row 
#' means and subsequently their log10 values.
#'
#' @param densities Numeric; a numeric vector of densities. Typically 
#' calculated with the \link{\code{calculateCostDensity}}.function.
#' @author Jason T. Serviss
calculateLogRowMeans <- function(densities) {
    .Call('_sp_scRNAseq_calculateLogRowMeans', PACKAGE = 'sp.scRNAseq', densities)
}

#' fixNegInf
#' 
#' This function takes a numeric vector and replaces -Inf values with 
#' -323.0052. Note: since log10(10^-324) gives -Inf but log10(10^-323) 
#' gives -323.0052
#'
#' @param means Numeric; a numeric vector of log10 row means. Typically 
#' calculated with the \link{\code{calculateLogRowMeans}}.function.
#' @author Jason T. Serviss
fixNegInf <- function(means) {
    .Call('_sp_scRNAseq_fixNegInf', PACKAGE = 'sp.scRNAseq', means)
}

#' costNegSum
#' 
#' This function takes a numeric vector and calculates the negative sum.
#'
#' @param means Numeric; a numeric vector of log10 row means. Typically 
#' calculated with the \link{\code{calculateLogRowMeans}}.function with the 
#' -Inf values replaced by the \link{\code{fixNegInf}} function.
#' @author Jason T. Serviss
costNegSum <- function(means) {
    .Call('_sp_scRNAseq_costNegSum', PACKAGE = 'sp.scRNAseq', means)
}

#' calculateCostEigen
#' 
#' This function takes a vector of gene counts per million for one multiplet 
#' that is being deconvoluted and a matrix of synthetic multiplets and 
#' calculates the cost which is returned to the optimization algorithm during
#' deconvolution.
#'
#' @param oneMultiplet Numeric; a numeric vector of counts per million for one
#' multiplet.
#' @param syntheticMultiplets Matrix; a numeric matrix of synthetic multiplets
#' with samples as columns and genes as rows.
#' @author Jason T. Serviss
#' @export
calculateCostEigen <- function(oneMultiplet, syntheticMultiplets) {
    .Call('_sp_scRNAseq_calculateCostEigen', PACKAGE = 'sp.scRNAseq', oneMultiplet, syntheticMultiplets)
}

#' calculateCostC
#' 
#' Wrapper for deconvolution cost function using the Eigen C++ library.
#'
#' @param singlets Matrix; a counts matrix with cells/samples as columns and 
#' genes as rows.
#' @param classes Character; a character vector of classes with length equal to
#' the number of cells for which counts exist.
#' @param fractions Numeric; a numeric vector with length equal to 
#' ncol(singlets) indicating the fractions that each column should be 
#' multiplied with.
#' @param n Integer; length 1 integer indicating the number of synthetic 
#' multiplets to generate.
#' @author Jason T. Serviss
#' @export
calculateCostC <- function(oneMultiplet, singlets, classes, fractions, n) {
    .Call('_sp_scRNAseq_calculateCostC', PACKAGE = 'sp.scRNAseq', oneMultiplet, singlets, classes, fractions, n)
}

