# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' sampleSingletsArma
#' 
#' This function takes a character vector of classes/cell with the same order
#' as the cells in the counts matrix. It returns one random index per unique
#' class and returns them as a integer vector.
#'
#' @param classes Character; a character vector of classes with length equal to
#' the number of cells for which counts exist.
#' @author Jason T. Serviss
#' @export
sampleSingletsArma <- function(classes) {
    .Call('_sp_scRNAseq_sampleSingletsArma', PACKAGE = 'sp.scRNAseq', classes)
}

#' subsetSingletsArma
#' 
#' This function takes a counts matrix and subsets the columns according to the
#' indices provided by the idxToSubset argument.
#'
#' @param singlets Matrix; a counts matrix with cells/samples as columns and 
#' genes as rows.
#' @param idxToSubset Integer; the indexes of cells/samples to be subset. 
#' @author Jason T. Serviss
#' @export
subsetSingletsArma <- function(singlets, idxToSubset) {
    .Call('_sp_scRNAseq_subsetSingletsArma', PACKAGE = 'sp.scRNAseq', singlets, idxToSubset)
}

#' normalizeFractionsArma
#' 
#' Takes a numeric vector and scales to [0, 1] by dividing with its sum.
#'
#' @param fractions Numeric; a numeric vector.
#' @author Jason T. Serviss
#' @export
normalizeFractionsArma <- function(fractions) {
    .Call('_sp_scRNAseq_normalizeFractionsArma', PACKAGE = 'sp.scRNAseq', fractions)
}

#' adjustAccordingToFractionsArma
#' 
#' This function takes a counts matrix and subsets the columns according to the
#' indices provided by the idxToSubset argument.
#'
#' @param fractions Numeric; a numeric vector with length equal to 
#' ncol(singlets) indicating the fractions that each column should be 
#' multiplied with.
#' @param singlets Matrix; a counts matrix with cells/samples as columns and 
#' genes as rows.
#' @author Jason T. Serviss
#' @export
adjustAccordingToFractionsArma <- function(fractions, singlets) {
    .Call('_sp_scRNAseq_adjustAccordingToFractionsArma', PACKAGE = 'sp.scRNAseq', fractions, singlets)
}

#' multipletSumsArma
#' 
#' This function takes a counts matrix and calculates the row sums. Output is
#' subsequently rounded for integration downstream.
#'
#' @param adjusted Matrix; a counts matrix with cells/samples as columns and 
#' genes as rows.
#' @author Jason T. Serviss
#' @export
multipletSumsArma <- function(adjusted) {
    .Call('_sp_scRNAseq_multipletSumsArma', PACKAGE = 'sp.scRNAseq', adjusted)
}

#' poissonSampleArma
#' 
#' This function takes the rowSums calculated by the 
#' \code{\link{multipletSumsArma}}.function and randomly samples 1 value for 
#' each input using the Poisson distribution and the input value as lambda.
#' @param rsRcpp Integer; vector of rounded row sums.
#' @author Jason T. Serviss
#' @export
poissonSampleArma <- function(rsRcpp) {
    .Call('_sp_scRNAseq_poissonSampleArma', PACKAGE = 'sp.scRNAseq', rsRcpp)
}

#' vecToMatArma
#' 
#' This function takes a vector and reformats it to a matrix in a column-wise
#' fashion.
#'
#' @param vec Numeric; the vector to reformat.
#' @param nr integer; length 1 integer indicating the number of matrix rows.
#' @param nc integer; length 1 integer indicating the number of matrix columns.
#' @author Jason T. Serviss
#' @export
vecToMatArma <- function(vec, nr, nc) {
    .Call('_sp_scRNAseq_vecToMatArma', PACKAGE = 'sp.scRNAseq', vec, nr, nc)
}

#' cpmArma
#' 
#' Takes a numeric matrix of counts and calculates counts per million.
#'
#' @param counts Matrix; a counts matrix. Must be formated as numeric.
#' @author Jason T. Serviss
#' @export
cpmArma <- function(counts) {
    .Call('_sp_scRNAseq_cpmArma', PACKAGE = 'sp.scRNAseq', counts)
}

#' calculateCostDensityArma
#' 
#' This function takes a vector of gene counts per million for one multiplet 
#' that is being deconvoluted and a matrix of synthetic multiplets. It then 
#' calculates the poisson density for each gene count and each corresponding 
#' value in the matrix row.
#'
#' @param oneMultiplet Numeric; a numeric vector of counts per million for one
#' multiplet.
#' @param syntheticMultiplets Matrix; a numeric matrix of synthetic multiplets
#' with samples as columns and genes as rows.
#' @author Jason T. Serviss
calculateCostDensityArma <- function(oneMultiplet, syntheticMultiplets) {
    .Call('_sp_scRNAseq_calculateCostDensityArma', PACKAGE = 'sp.scRNAseq', oneMultiplet, syntheticMultiplets)
}

#' calculateLogRowMeansArma
#' 
#' This function takes a matrix of poisson densities and calculates the row 
#' means and subsequently their log10 values.
#'
#' @param densities Numeric; a numeric vector of densities.
#' @author Jason T. Serviss
calculateLogRowMeansArma <- function(densities) {
    .Call('_sp_scRNAseq_calculateLogRowMeansArma', PACKAGE = 'sp.scRNAseq', densities)
}

#' fixNegInfArma
#' 
#' This function takes a numeric vector and replaces -Inf values with 
#' -323.0052. Note: since log10(10^-324) gives -Inf but log10(10^-323) 
#' gives -323.0052
#'
#' @param means Numeric; a numeric vector of log10 row means.
#' @author Jason T. Serviss
fixNegInfArma <- function(means) {
    .Call('_sp_scRNAseq_fixNegInfArma', PACKAGE = 'sp.scRNAseq', means)
}

#' costNegSumArma
#' 
#' This function takes a numeric vector and calculates the negative sum.
#'
#' @param means Numeric; a numeric vector of log10 row means.
#' @author Jason T. Serviss
costNegSumArma <- function(means) {
    .Call('_sp_scRNAseq_costNegSumArma', PACKAGE = 'sp.scRNAseq', means)
}

#' calculateCostArma
#' 
#' This function takes a vector of gene counts per million for one multiplet 
#' that is being deconvoluted and a matrix of synthetic multiplets and 
#' calculates the cost which is returned to the optimization algorithm during
#' deconvolution.
#'
#' @param oneMultiplet Numeric; a numeric vector of counts per million for one
#' multiplet.
#' @param syntheticMultiplets Matrix; a numeric matrix of synthetic multiplets
#' with samples as columns and genes as rows.
#' @author Jason T. Serviss
#' @export
calculateCostArma <- function(oneMultiplet, syntheticMultiplets) {
    .Call('_sp_scRNAseq_calculateCostArma', PACKAGE = 'sp.scRNAseq', oneMultiplet, syntheticMultiplets)
}

#' preallocCost
#' 
#' Calculates cost with a preallocated matrix of subsetted singlets.
#'
#' @param oneMultiplet Numeric; a numeric vector of counts per million for one
#' multiplet.
#' @param singletSubset Matrix; Numeric matrix with the preallocated singlets. 
#' Each of the n synthetic multiplets should be stacked, i.e. rbind.
#' @param fractions Numeric; a numeric vector with length equal to 
#' ncol(singlets) indicating the fractions that each column should be 
#' multiplied with.
#' @author Jason T. Serviss
#' @export
preallocCost <- function(oneMultiplet, singletSubset, fractions) {
    .Call('_sp_scRNAseq_preallocCost', PACKAGE = 'sp.scRNAseq', oneMultiplet, singletSubset, fractions)
}

